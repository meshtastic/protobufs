// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file meshtastic/deviceonly.proto (package meshtastic, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Channel } from "./channel_pb";
import { file_meshtastic_channel } from "./channel_pb";
import type { Config_DeviceConfig_Role } from "./config_pb";
import { file_meshtastic_config } from "./config_pb";
import type { LocalConfig, LocalModuleConfig } from "./localonly_pb";
import { file_meshtastic_localonly } from "./localonly_pb";
import type { HardwareModel, MeshPacket, MyNodeInfo, NodeRemoteHardwarePin, Position_LocSource, User } from "./mesh_pb";
import { file_meshtastic_mesh } from "./mesh_pb";
import type { DeviceMetrics } from "./telemetry_pb";
import { file_meshtastic_telemetry } from "./telemetry_pb";
import { file_nanopb } from "../nanopb_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file meshtastic/deviceonly.proto.
 */
export const file_meshtastic_deviceonly: GenFile = /*@__PURE__*/
  fileDesc("ChttZXNodGFzdGljL2RldmljZW9ubHkucHJvdG8SCm1lc2h0YXN0aWMikAEKDFBvc2l0aW9uTGl0ZRISCgpsYXRpdHVkZV9pGAEgASgPEhMKC2xvbmdpdHVkZV9pGAIgASgPEhAKCGFsdGl0dWRlGAMgASgFEgwKBHRpbWUYBCABKAcSNwoPbG9jYXRpb25fc291cmNlGAUgASgOMh4ubWVzaHRhc3RpYy5Qb3NpdGlvbi5Mb2NTb3VyY2UiggIKCFVzZXJMaXRlEhMKB21hY2FkZHIYASABKAxCAhgBEhEKCWxvbmdfbmFtZRgCIAEoCRISCgpzaG9ydF9uYW1lGAMgASgJEisKCGh3X21vZGVsGAQgASgOMhkubWVzaHRhc3RpYy5IYXJkd2FyZU1vZGVsEhMKC2lzX2xpY2Vuc2VkGAUgASgIEjIKBHJvbGUYBiABKA4yJC5tZXNodGFzdGljLkNvbmZpZy5EZXZpY2VDb25maWcuUm9sZRISCgpwdWJsaWNfa2V5GAcgASgMEhwKD2lzX3VubWVzc2FnYWJsZRgJIAEoCEgAiAEBQhIKEF9pc191bm1lc3NhZ2FibGUi1QIKDE5vZGVJbmZvTGl0ZRILCgNudW0YASABKA0SIgoEdXNlchgCIAEoCzIULm1lc2h0YXN0aWMuVXNlckxpdGUSKgoIcG9zaXRpb24YAyABKAsyGC5tZXNodGFzdGljLlBvc2l0aW9uTGl0ZRILCgNzbnIYBCABKAISEgoKbGFzdF9oZWFyZBgFIAEoBxIxCg5kZXZpY2VfbWV0cmljcxgGIAEoCzIZLm1lc2h0YXN0aWMuRGV2aWNlTWV0cmljcxIPCgdjaGFubmVsGAcgASgNEhAKCHZpYV9tcXR0GAggASgIEhYKCWhvcHNfYXdheRgJIAEoDUgAiAEBEhMKC2lzX2Zhdm9yaXRlGAogASgIEhIKCmlzX2lnbm9yZWQYCyABKAgSEAoIbmV4dF9ob3AYDCABKA0SEAoIYml0ZmllbGQYDSABKA1CDAoKX2hvcHNfYXdheSLrAgoLRGV2aWNlU3RhdGUSJwoHbXlfbm9kZRgCIAEoCzIWLm1lc2h0YXN0aWMuTXlOb2RlSW5mbxIfCgVvd25lchgDIAEoCzIQLm1lc2h0YXN0aWMuVXNlchItCg1yZWNlaXZlX3F1ZXVlGAUgAygLMhYubWVzaHRhc3RpYy5NZXNoUGFja2V0Eg8KB3ZlcnNpb24YCCABKA0SLwoPcnhfdGV4dF9tZXNzYWdlGAcgASgLMhYubWVzaHRhc3RpYy5NZXNoUGFja2V0EhMKB25vX3NhdmUYCSABKAhCAhgBEhkKDWRpZF9ncHNfcmVzZXQYCyABKAhCAhgBEisKC3J4X3dheXBvaW50GAwgASgLMhYubWVzaHRhc3RpYy5NZXNoUGFja2V0EkQKGW5vZGVfcmVtb3RlX2hhcmR3YXJlX3BpbnMYDSADKAsyIS5tZXNodGFzdGljLk5vZGVSZW1vdGVIYXJkd2FyZVBpbiJ0CgxOb2RlRGF0YWJhc2USDwoHdmVyc2lvbhgBIAEoDRJTCgVub2RlcxgCIAMoCzIYLm1lc2h0YXN0aWMuTm9kZUluZm9MaXRlQiqSPyeSASRzdGQ6OnZlY3RvcjxtZXNodGFzdGljX05vZGVJbmZvTGl0ZT4iRQoLQ2hhbm5lbEZpbGUSJQoIY2hhbm5lbHMYASADKAsyEy5tZXNodGFzdGljLkNoYW5uZWwSDwoHdmVyc2lvbhgCIAEoDSLiAQoRQmFja3VwUHJlZmVyZW5jZXMSDwoHdmVyc2lvbhgBIAEoDRIRCgl0aW1lc3RhbXAYAiABKAcSJwoGY29uZmlnGAMgASgLMhcubWVzaHRhc3RpYy5Mb2NhbENvbmZpZxI0Cg1tb2R1bGVfY29uZmlnGAQgASgLMh0ubWVzaHRhc3RpYy5Mb2NhbE1vZHVsZUNvbmZpZxIpCghjaGFubmVscxgFIAEoCzIXLm1lc2h0YXN0aWMuQ2hhbm5lbEZpbGUSHwoFb3duZXIYBiABKAsyEC5tZXNodGFzdGljLlVzZXJCbgoUb3JnLm1lc2h0YXN0aWMucHJvdG9CCkRldmljZU9ubHlaImdpdGh1Yi5jb20vbWVzaHRhc3RpYy9nby9nZW5lcmF0ZWSqAhRNZXNodGFzdGljLlByb3RvYnVmc7oCAJI/C8IBCDx2ZWN0b3I+YgZwcm90bzM", [file_meshtastic_channel, file_meshtastic_config, file_meshtastic_localonly, file_meshtastic_mesh, file_meshtastic_telemetry, file_nanopb]);

/**
 *
 * Position with static location information only for NodeDBLite
 *
 * @generated from message meshtastic.PositionLite
 */
export type PositionLite = Message<"meshtastic.PositionLite"> & {
  /**
   *
   * The new preferred location encoding, multiply by 1e-7 to get degrees
   * in floating point
   *
   * @generated from field: sfixed32 latitude_i = 1;
   */
  latitudeI: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: sfixed32 longitude_i = 2;
   */
  longitudeI: number;

  /**
   *
   * In meters above MSL (but see issue #359)
   *
   * @generated from field: int32 altitude = 3;
   */
  altitude: number;

  /**
   *
   * This is usually not sent over the mesh (to save space), but it is sent
   * from the phone so that the local device can set its RTC If it is sent over
   * the mesh (because there are devices on the mesh without GPS), it will only
   * be sent by devices which has a hardware GPS clock.
   * seconds since 1970
   *
   * @generated from field: fixed32 time = 4;
   */
  time: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: meshtastic.Position.LocSource location_source = 5;
   */
  locationSource: Position_LocSource;
};

/**
 * Describes the message meshtastic.PositionLite.
 * Use `create(PositionLiteSchema)` to create a new message.
 */
export const PositionLiteSchema: GenMessage<PositionLite> = /*@__PURE__*/
  messageDesc(file_meshtastic_deviceonly, 0);

/**
 * @generated from message meshtastic.UserLite
 */
export type UserLite = Message<"meshtastic.UserLite"> & {
  /**
   *
   * This is the addr of the radio.
   *
   * @generated from field: bytes macaddr = 1 [deprecated = true];
   * @deprecated
   */
  macaddr: Uint8Array;

  /**
   *
   * A full name for this user, i.e. "Kevin Hester"
   *
   * @generated from field: string long_name = 2;
   */
  longName: string;

  /**
   *
   * A VERY short name, ideally two characters.
   * Suitable for a tiny OLED screen
   *
   * @generated from field: string short_name = 3;
   */
  shortName: string;

  /**
   *
   * TBEAM, HELTEC, etc...
   * Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
   * Apps will still need the string here for older builds
   * (so OTA update can find the right image), but if the enum is available it will be used instead.
   *
   * @generated from field: meshtastic.HardwareModel hw_model = 4;
   */
  hwModel: HardwareModel;

  /**
   *
   * In some regions Ham radio operators have different bandwidth limitations than others.
   * If this user is a licensed operator, set this flag.
   * Also, "long_name" should be their licence number.
   *
   * @generated from field: bool is_licensed = 5;
   */
  isLicensed: boolean;

  /**
   *
   * Indicates that the user's role in the mesh
   *
   * @generated from field: meshtastic.Config.DeviceConfig.Role role = 6;
   */
  role: Config_DeviceConfig_Role;

  /**
   *
   * The public key of the user's device.
   * This is sent out to other nodes on the mesh to allow them to compute a shared secret key.
   *
   * @generated from field: bytes public_key = 7;
   */
  publicKey: Uint8Array;

  /**
   *
   * Whether or not the node can be messaged
   *
   * @generated from field: optional bool is_unmessagable = 9;
   */
  isUnmessagable?: boolean;
};

/**
 * Describes the message meshtastic.UserLite.
 * Use `create(UserLiteSchema)` to create a new message.
 */
export const UserLiteSchema: GenMessage<UserLite> = /*@__PURE__*/
  messageDesc(file_meshtastic_deviceonly, 1);

/**
 * @generated from message meshtastic.NodeInfoLite
 */
export type NodeInfoLite = Message<"meshtastic.NodeInfoLite"> & {
  /**
   *
   * The node number
   *
   * @generated from field: uint32 num = 1;
   */
  num: number;

  /**
   *
   * The user info for this node
   *
   * @generated from field: meshtastic.UserLite user = 2;
   */
  user?: UserLite;

  /**
   *
   * This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
   * Position.time now indicates the last time we received a POSITION from that node.
   *
   * @generated from field: meshtastic.PositionLite position = 3;
   */
  position?: PositionLite;

  /**
   *
   * Returns the Signal-to-noise ratio (SNR) of the last received message,
   * as measured by the receiver. Return SNR of the last received message in dB
   *
   * @generated from field: float snr = 4;
   */
  snr: number;

  /**
   *
   * Set to indicate the last time we received a packet from this node
   *
   * @generated from field: fixed32 last_heard = 5;
   */
  lastHeard: number;

  /**
   *
   * The latest device metrics for the node.
   *
   * @generated from field: meshtastic.DeviceMetrics device_metrics = 6;
   */
  deviceMetrics?: DeviceMetrics;

  /**
   *
   * local channel index we heard that node on. Only populated if its not the default channel.
   *
   * @generated from field: uint32 channel = 7;
   */
  channel: number;

  /**
   *
   * True if we witnessed the node over MQTT instead of LoRA transport
   *
   * @generated from field: bool via_mqtt = 8;
   */
  viaMqtt: boolean;

  /**
   *
   * Number of hops away from us this node is (0 if direct neighbor)
   *
   * @generated from field: optional uint32 hops_away = 9;
   */
  hopsAway?: number;

  /**
   *
   * True if node is in our favorites list
   * Persists between NodeDB internal clean ups
   *
   * @generated from field: bool is_favorite = 10;
   */
  isFavorite: boolean;

  /**
   *
   * True if node is in our ignored list
   * Persists between NodeDB internal clean ups
   *
   * @generated from field: bool is_ignored = 11;
   */
  isIgnored: boolean;

  /**
   *
   * Last byte of the node number of the node that should be used as the next hop to reach this node.
   *
   * @generated from field: uint32 next_hop = 12;
   */
  nextHop: number;

  /**
   *
   * Bitfield for storing booleans.
   * LSB 0 is_key_manually_verified
   *
   * @generated from field: uint32 bitfield = 13;
   */
  bitfield: number;
};

/**
 * Describes the message meshtastic.NodeInfoLite.
 * Use `create(NodeInfoLiteSchema)` to create a new message.
 */
export const NodeInfoLiteSchema: GenMessage<NodeInfoLite> = /*@__PURE__*/
  messageDesc(file_meshtastic_deviceonly, 2);

/**
 *
 * This message is never sent over the wire, but it is used for serializing DB
 * state to flash in the device code
 * FIXME, since we write this each time we enter deep sleep (and have infinite
 * flash) it would be better to use some sort of append only data structure for
 * the receive queue and use the preferences store for the other stuff
 *
 * @generated from message meshtastic.DeviceState
 */
export type DeviceState = Message<"meshtastic.DeviceState"> & {
  /**
   *
   * Read only settings/info about this node
   *
   * @generated from field: meshtastic.MyNodeInfo my_node = 2;
   */
  myNode?: MyNodeInfo;

  /**
   *
   * My owner info
   *
   * @generated from field: meshtastic.User owner = 3;
   */
  owner?: User;

  /**
   *
   * Received packets saved for delivery to the phone
   *
   * @generated from field: repeated meshtastic.MeshPacket receive_queue = 5;
   */
  receiveQueue: MeshPacket[];

  /**
   *
   * A version integer used to invalidate old save files when we make
   * incompatible changes This integer is set at build time and is private to
   * NodeDB.cpp in the device code.
   *
   * @generated from field: uint32 version = 8;
   */
  version: number;

  /**
   *
   * We keep the last received text message (only) stored in the device flash,
   * so we can show it on the screen.
   * Might be null
   *
   * @generated from field: meshtastic.MeshPacket rx_text_message = 7;
   */
  rxTextMessage?: MeshPacket;

  /**
   *
   * Used only during development.
   * Indicates developer is testing and changes should never be saved to flash.
   * Deprecated in 2.3.1
   *
   * @generated from field: bool no_save = 9 [deprecated = true];
   * @deprecated
   */
  noSave: boolean;

  /**
   *
   * Previously used to manage GPS factory resets.
   * Deprecated in 2.5.23
   *
   * @generated from field: bool did_gps_reset = 11 [deprecated = true];
   * @deprecated
   */
  didGpsReset: boolean;

  /**
   *
   * We keep the last received waypoint stored in the device flash,
   * so we can show it on the screen.
   * Might be null
   *
   * @generated from field: meshtastic.MeshPacket rx_waypoint = 12;
   */
  rxWaypoint?: MeshPacket;

  /**
   *
   * The mesh's nodes with their available gpio pins for RemoteHardware module
   *
   * @generated from field: repeated meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 13;
   */
  nodeRemoteHardwarePins: NodeRemoteHardwarePin[];
};

/**
 * Describes the message meshtastic.DeviceState.
 * Use `create(DeviceStateSchema)` to create a new message.
 */
export const DeviceStateSchema: GenMessage<DeviceState> = /*@__PURE__*/
  messageDesc(file_meshtastic_deviceonly, 3);

/**
 * @generated from message meshtastic.NodeDatabase
 */
export type NodeDatabase = Message<"meshtastic.NodeDatabase"> & {
  /**
   *
   * A version integer used to invalidate old save files when we make
   * incompatible changes This integer is set at build time and is private to
   * NodeDB.cpp in the device code.
   *
   * @generated from field: uint32 version = 1;
   */
  version: number;

  /**
   *
   * New lite version of NodeDB to decrease memory footprint
   *
   * @generated from field: repeated meshtastic.NodeInfoLite nodes = 2;
   */
  nodes: NodeInfoLite[];
};

/**
 * Describes the message meshtastic.NodeDatabase.
 * Use `create(NodeDatabaseSchema)` to create a new message.
 */
export const NodeDatabaseSchema: GenMessage<NodeDatabase> = /*@__PURE__*/
  messageDesc(file_meshtastic_deviceonly, 4);

/**
 *
 * The on-disk saved channels
 *
 * @generated from message meshtastic.ChannelFile
 */
export type ChannelFile = Message<"meshtastic.ChannelFile"> & {
  /**
   *
   * The channels our node knows about
   *
   * @generated from field: repeated meshtastic.Channel channels = 1;
   */
  channels: Channel[];

  /**
   *
   * A version integer used to invalidate old save files when we make
   * incompatible changes This integer is set at build time and is private to
   * NodeDB.cpp in the device code.
   *
   * @generated from field: uint32 version = 2;
   */
  version: number;
};

/**
 * Describes the message meshtastic.ChannelFile.
 * Use `create(ChannelFileSchema)` to create a new message.
 */
export const ChannelFileSchema: GenMessage<ChannelFile> = /*@__PURE__*/
  messageDesc(file_meshtastic_deviceonly, 5);

/**
 *
 * The on-disk backup of the node's preferences
 *
 * @generated from message meshtastic.BackupPreferences
 */
export type BackupPreferences = Message<"meshtastic.BackupPreferences"> & {
  /**
   *
   * The version of the backup
   *
   * @generated from field: uint32 version = 1;
   */
  version: number;

  /**
   *
   * The timestamp of the backup (if node has time)
   *
   * @generated from field: fixed32 timestamp = 2;
   */
  timestamp: number;

  /**
   *
   * The node's configuration
   *
   * @generated from field: meshtastic.LocalConfig config = 3;
   */
  config?: LocalConfig;

  /**
   *
   * The node's module configuration
   *
   * @generated from field: meshtastic.LocalModuleConfig module_config = 4;
   */
  moduleConfig?: LocalModuleConfig;

  /**
   *
   * The node's channels
   *
   * @generated from field: meshtastic.ChannelFile channels = 5;
   */
  channels?: ChannelFile;

  /**
   *
   * The node's user (owner) information
   *
   * @generated from field: meshtastic.User owner = 6;
   */
  owner?: User;
};

/**
 * Describes the message meshtastic.BackupPreferences.
 * Use `create(BackupPreferencesSchema)` to create a new message.
 */
export const BackupPreferencesSchema: GenMessage<BackupPreferences> = /*@__PURE__*/
  messageDesc(file_meshtastic_deviceonly, 6);

