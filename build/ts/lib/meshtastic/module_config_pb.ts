// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file meshtastic/module_config.proto (package meshtastic, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file meshtastic/module_config.proto.
 */
export const file_meshtastic_module_config: GenFile = /*@__PURE__*/
  fileDesc("Ch5tZXNodGFzdGljL21vZHVsZV9jb25maWcucHJvdG8SCm1lc2h0YXN0aWMitSYKDE1vZHVsZUNvbmZpZxIzCgRtcXR0GAEgASgLMiMubWVzaHRhc3RpYy5Nb2R1bGVDb25maWcuTVFUVENvbmZpZ0gAEjcKBnNlcmlhbBgCIAEoCzIlLm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLlNlcmlhbENvbmZpZ0gAElQKFWV4dGVybmFsX25vdGlmaWNhdGlvbhgDIAEoCzIzLm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLkV4dGVybmFsTm90aWZpY2F0aW9uQ29uZmlnSAASRAoNc3RvcmVfZm9yd2FyZBgEIAEoCzIrLm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLlN0b3JlRm9yd2FyZENvbmZpZ0gAEj4KCnJhbmdlX3Rlc3QYBSABKAsyKC5tZXNodGFzdGljLk1vZHVsZUNvbmZpZy5SYW5nZVRlc3RDb25maWdIABI9Cgl0ZWxlbWV0cnkYBiABKAsyKC5tZXNodGFzdGljLk1vZHVsZUNvbmZpZy5UZWxlbWV0cnlDb25maWdIABJGCg5jYW5uZWRfbWVzc2FnZRgHIAEoCzIsLm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLkNhbm5lZE1lc3NhZ2VDb25maWdIABI1CgVhdWRpbxgIIAEoCzIkLm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLkF1ZGlvQ29uZmlnSAASSAoPcmVtb3RlX2hhcmR3YXJlGAkgASgLMi0ubWVzaHRhc3RpYy5Nb2R1bGVDb25maWcuUmVtb3RlSGFyZHdhcmVDb25maWdIABJECg1uZWlnaGJvcl9pbmZvGAogASgLMisubWVzaHRhc3RpYy5Nb2R1bGVDb25maWcuTmVpZ2hib3JJbmZvQ29uZmlnSAASSgoQYW1iaWVudF9saWdodGluZxgLIAEoCzIuLm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLkFtYmllbnRMaWdodGluZ0NvbmZpZ0gAEkoKEGRldGVjdGlvbl9zZW5zb3IYDCABKAsyLi5tZXNodGFzdGljLk1vZHVsZUNvbmZpZy5EZXRlY3Rpb25TZW5zb3JDb25maWdIABI/CgpwYXhjb3VudGVyGA0gASgLMikubWVzaHRhc3RpYy5Nb2R1bGVDb25maWcuUGF4Y291bnRlckNvbmZpZ0gAGrACCgpNUVRUQ29uZmlnEg8KB2VuYWJsZWQYASABKAgSDwoHYWRkcmVzcxgCIAEoCRIQCgh1c2VybmFtZRgDIAEoCRIQCghwYXNzd29yZBgEIAEoCRIaChJlbmNyeXB0aW9uX2VuYWJsZWQYBSABKAgSFAoManNvbl9lbmFibGVkGAYgASgIEhMKC3Rsc19lbmFibGVkGAcgASgIEgwKBHJvb3QYCCABKAkSHwoXcHJveHlfdG9fY2xpZW50X2VuYWJsZWQYCSABKAgSHQoVbWFwX3JlcG9ydGluZ19lbmFibGVkGAogASgIEkcKE21hcF9yZXBvcnRfc2V0dGluZ3MYCyABKAsyKi5tZXNodGFzdGljLk1vZHVsZUNvbmZpZy5NYXBSZXBvcnRTZXR0aW5ncxpuChFNYXBSZXBvcnRTZXR0aW5ncxIdChVwdWJsaXNoX2ludGVydmFsX3NlY3MYASABKA0SGgoScG9zaXRpb25fcHJlY2lzaW9uGAIgASgNEh4KFnNob3VsZF9yZXBvcnRfbG9jYXRpb24YAyABKAgaggEKFFJlbW90ZUhhcmR3YXJlQ29uZmlnEg8KB2VuYWJsZWQYASABKAgSIgoaYWxsb3dfdW5kZWZpbmVkX3Bpbl9hY2Nlc3MYAiABKAgSNQoOYXZhaWxhYmxlX3BpbnMYAyADKAsyHS5tZXNodGFzdGljLlJlbW90ZUhhcmR3YXJlUGluGloKEk5laWdoYm9ySW5mb0NvbmZpZxIPCgdlbmFibGVkGAEgASgIEhcKD3VwZGF0ZV9pbnRlcnZhbBgCIAEoDRIaChJ0cmFuc21pdF9vdmVyX2xvcmEYAyABKAgalwMKFURldGVjdGlvblNlbnNvckNvbmZpZxIPCgdlbmFibGVkGAEgASgIEh4KFm1pbmltdW1fYnJvYWRjYXN0X3NlY3MYAiABKA0SHAoUc3RhdGVfYnJvYWRjYXN0X3NlY3MYAyABKA0SEQoJc2VuZF9iZWxsGAQgASgIEgwKBG5hbWUYBSABKAkSEwoLbW9uaXRvcl9waW4YBiABKA0SWgoWZGV0ZWN0aW9uX3RyaWdnZXJfdHlwZRgHIAEoDjI6Lm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLkRldGVjdGlvblNlbnNvckNvbmZpZy5UcmlnZ2VyVHlwZRISCgp1c2VfcHVsbHVwGAggASgIIogBCgtUcmlnZ2VyVHlwZRINCglMT0dJQ19MT1cQABIOCgpMT0dJQ19ISUdIEAESEAoMRkFMTElOR19FREdFEAISDwoLUklTSU5HX0VER0UQAxIaChZFSVRIRVJfRURHRV9BQ1RJVkVfTE9XEAQSGwoXRUlUSEVSX0VER0VfQUNUSVZFX0hJR0gQBRrkAgoLQXVkaW9Db25maWcSFgoOY29kZWMyX2VuYWJsZWQYASABKAgSDwoHcHR0X3BpbhgCIAEoDRJACgdiaXRyYXRlGAMgASgOMi8ubWVzaHRhc3RpYy5Nb2R1bGVDb25maWcuQXVkaW9Db25maWcuQXVkaW9fQmF1ZBIOCgZpMnNfd3MYBCABKA0SDgoGaTJzX3NkGAUgASgNEg8KB2kyc19kaW4YBiABKA0SDwoHaTJzX3NjaxgHIAEoDSKnAQoKQXVkaW9fQmF1ZBISCg5DT0RFQzJfREVGQVVMVBAAEg8KC0NPREVDMl8zMjAwEAESDwoLQ09ERUMyXzI0MDAQAhIPCgtDT0RFQzJfMTYwMBADEg8KC0NPREVDMl8xNDAwEAQSDwoLQ09ERUMyXzEzMDAQBRIPCgtDT0RFQzJfMTIwMBAGEg4KCkNPREVDMl83MDAQBxIPCgtDT0RFQzJfNzAwQhAIGnYKEFBheGNvdW50ZXJDb25maWcSDwoHZW5hYmxlZBgBIAEoCBIiChpwYXhjb3VudGVyX3VwZGF0ZV9pbnRlcnZhbBgCIAEoDRIWCg53aWZpX3RocmVzaG9sZBgDIAEoBRIVCg1ibGVfdGhyZXNob2xkGAQgASgFGowFCgxTZXJpYWxDb25maWcSDwoHZW5hYmxlZBgBIAEoCBIMCgRlY2hvGAIgASgIEgsKA3J4ZBgDIAEoDRILCgN0eGQYBCABKA0SPwoEYmF1ZBgFIAEoDjIxLm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLlNlcmlhbENvbmZpZy5TZXJpYWxfQmF1ZBIPCgd0aW1lb3V0GAYgASgNEj8KBG1vZGUYByABKA4yMS5tZXNodGFzdGljLk1vZHVsZUNvbmZpZy5TZXJpYWxDb25maWcuU2VyaWFsX01vZGUSJAocb3ZlcnJpZGVfY29uc29sZV9zZXJpYWxfcG9ydBgIIAEoCCKKAgoLU2VyaWFsX0JhdWQSEAoMQkFVRF9ERUZBVUxUEAASDAoIQkFVRF8xMTAQARIMCghCQVVEXzMwMBACEgwKCEJBVURfNjAwEAMSDQoJQkFVRF8xMjAwEAQSDQoJQkFVRF8yNDAwEAUSDQoJQkFVRF80ODAwEAYSDQoJQkFVRF85NjAwEAcSDgoKQkFVRF8xOTIwMBAIEg4KCkJBVURfMzg0MDAQCRIOCgpCQVVEXzU3NjAwEAoSDwoLQkFVRF8xMTUyMDAQCxIPCgtCQVVEXzIzMDQwMBAMEg8KC0JBVURfNDYwODAwEA0SDwoLQkFVRF81NzYwMDAQDhIPCgtCQVVEXzkyMTYwMBAPIn0KC1NlcmlhbF9Nb2RlEgsKB0RFRkFVTFQQABIKCgZTSU1QTEUQARIJCgVQUk9UTxACEgsKB1RFWFRNU0cQAxIICgROTUVBEAQSCwoHQ0FMVE9QTxAFEggKBFdTODUQBhINCglWRV9ESVJFQ1QQBxINCglNU19DT05GSUcQCBrpAgoaRXh0ZXJuYWxOb3RpZmljYXRpb25Db25maWcSDwoHZW5hYmxlZBgBIAEoCBIRCglvdXRwdXRfbXMYAiABKA0SDgoGb3V0cHV0GAMgASgNEhQKDG91dHB1dF92aWJyYRgIIAEoDRIVCg1vdXRwdXRfYnV6emVyGAkgASgNEg4KBmFjdGl2ZRgEIAEoCBIVCg1hbGVydF9tZXNzYWdlGAUgASgIEhsKE2FsZXJ0X21lc3NhZ2VfdmlicmEYCiABKAgSHAoUYWxlcnRfbWVzc2FnZV9idXp6ZXIYCyABKAgSEgoKYWxlcnRfYmVsbBgGIAEoCBIYChBhbGVydF9iZWxsX3ZpYnJhGAwgASgIEhkKEWFsZXJ0X2JlbGxfYnV6emVyGA0gASgIEg8KB3VzZV9wd20YByABKAgSEwoLbmFnX3RpbWVvdXQYDiABKA0SGQoRdXNlX2kyc19hc19idXp6ZXIYDyABKAgalwEKElN0b3JlRm9yd2FyZENvbmZpZxIPCgdlbmFibGVkGAEgASgIEhEKCWhlYXJ0YmVhdBgCIAEoCBIPCgdyZWNvcmRzGAMgASgNEhoKEmhpc3RvcnlfcmV0dXJuX21heBgEIAEoDRIdChVoaXN0b3J5X3JldHVybl93aW5kb3cYBSABKA0SEQoJaXNfc2VydmVyGAYgASgIGlkKD1JhbmdlVGVzdENvbmZpZxIPCgdlbmFibGVkGAEgASgIEg4KBnNlbmRlchgCIAEoDRIMCgRzYXZlGAMgASgIEhcKD2NsZWFyX29uX3JlYm9vdBgEIAEoCBrrAwoPVGVsZW1ldHJ5Q29uZmlnEh4KFmRldmljZV91cGRhdGVfaW50ZXJ2YWwYASABKA0SIwobZW52aXJvbm1lbnRfdXBkYXRlX2ludGVydmFsGAIgASgNEicKH2Vudmlyb25tZW50X21lYXN1cmVtZW50X2VuYWJsZWQYAyABKAgSIgoaZW52aXJvbm1lbnRfc2NyZWVuX2VuYWJsZWQYBCABKAgSJgoeZW52aXJvbm1lbnRfZGlzcGxheV9mYWhyZW5oZWl0GAUgASgIEhsKE2Fpcl9xdWFsaXR5X2VuYWJsZWQYBiABKAgSHAoUYWlyX3F1YWxpdHlfaW50ZXJ2YWwYByABKA0SIQoZcG93ZXJfbWVhc3VyZW1lbnRfZW5hYmxlZBgIIAEoCBIdChVwb3dlcl91cGRhdGVfaW50ZXJ2YWwYCSABKA0SHAoUcG93ZXJfc2NyZWVuX2VuYWJsZWQYCiABKAgSIgoaaGVhbHRoX21lYXN1cmVtZW50X2VuYWJsZWQYCyABKAgSHgoWaGVhbHRoX3VwZGF0ZV9pbnRlcnZhbBgMIAEoDRIdChVoZWFsdGhfc2NyZWVuX2VuYWJsZWQYDSABKAgSIAoYZGV2aWNlX3RlbGVtZXRyeV9lbmFibGVkGA4gASgIGt4EChNDYW5uZWRNZXNzYWdlQ29uZmlnEhcKD3JvdGFyeTFfZW5hYmxlZBgBIAEoCBIZChFpbnB1dGJyb2tlcl9waW5fYRgCIAEoDRIZChFpbnB1dGJyb2tlcl9waW5fYhgDIAEoDRIdChVpbnB1dGJyb2tlcl9waW5fcHJlc3MYBCABKA0SWQoUaW5wdXRicm9rZXJfZXZlbnRfY3cYBSABKA4yOy5tZXNodGFzdGljLk1vZHVsZUNvbmZpZy5DYW5uZWRNZXNzYWdlQ29uZmlnLklucHV0RXZlbnRDaGFyEloKFWlucHV0YnJva2VyX2V2ZW50X2NjdxgGIAEoDjI7Lm1lc2h0YXN0aWMuTW9kdWxlQ29uZmlnLkNhbm5lZE1lc3NhZ2VDb25maWcuSW5wdXRFdmVudENoYXISXAoXaW5wdXRicm9rZXJfZXZlbnRfcHJlc3MYByABKA4yOy5tZXNodGFzdGljLk1vZHVsZUNvbmZpZy5DYW5uZWRNZXNzYWdlQ29uZmlnLklucHV0RXZlbnRDaGFyEhcKD3VwZG93bjFfZW5hYmxlZBgIIAEoCBITCgdlbmFibGVkGAkgASgIQgIYARIeChJhbGxvd19pbnB1dF9zb3VyY2UYCiABKAlCAhgBEhEKCXNlbmRfYmVsbBgLIAEoCCJjCg5JbnB1dEV2ZW50Q2hhchIICgROT05FEAASBgoCVVAQERIICgRET1dOEBISCAoETEVGVBATEgkKBVJJR0hUEBQSCgoGU0VMRUNUEAoSCAoEQkFDSxAbEgoKBkNBTkNFTBAYGmUKFUFtYmllbnRMaWdodGluZ0NvbmZpZxIRCglsZWRfc3RhdGUYASABKAgSDwoHY3VycmVudBgCIAEoDRILCgNyZWQYAyABKA0SDQoFZ3JlZW4YBCABKA0SDAoEYmx1ZRgFIAEoDUIRCg9wYXlsb2FkX3ZhcmlhbnQiZAoRUmVtb3RlSGFyZHdhcmVQaW4SEAoIZ3Bpb19waW4YASABKA0SDAoEbmFtZRgCIAEoCRIvCgR0eXBlGAMgASgOMiEubWVzaHRhc3RpYy5SZW1vdGVIYXJkd2FyZVBpblR5cGUqSQoVUmVtb3RlSGFyZHdhcmVQaW5UeXBlEgsKB1VOS05PV04QABIQCgxESUdJVEFMX1JFQUQQARIRCg1ESUdJVEFMX1dSSVRFEAJCaAoUb3JnLm1lc2h0YXN0aWMucHJvdG9CEk1vZHVsZUNvbmZpZ1Byb3Rvc1oiZ2l0aHViLmNvbS9tZXNodGFzdGljL2dvL2dlbmVyYXRlZKoCFE1lc2h0YXN0aWMuUHJvdG9idWZzugIAYgZwcm90bzM");

/**
 *
 * Module Config
 *
 * @generated from message meshtastic.ModuleConfig
 */
export type ModuleConfig = Message<"meshtastic.ModuleConfig"> & {
  /**
   *
   * TODO: REPLACE
   *
   * @generated from oneof meshtastic.ModuleConfig.payload_variant
   */
  payloadVariant: {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
     */
    value: ModuleConfig_MQTTConfig;
    case: "mqtt";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.SerialConfig serial = 2;
     */
    value: ModuleConfig_SerialConfig;
    case: "serial";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
     */
    value: ModuleConfig_ExternalNotificationConfig;
    case: "externalNotification";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
     */
    value: ModuleConfig_StoreForwardConfig;
    case: "storeForward";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
     */
    value: ModuleConfig_RangeTestConfig;
    case: "rangeTest";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
     */
    value: ModuleConfig_TelemetryConfig;
    case: "telemetry";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
     */
    value: ModuleConfig_CannedMessageConfig;
    case: "cannedMessage";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.AudioConfig audio = 8;
     */
    value: ModuleConfig_AudioConfig;
    case: "audio";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 9;
     */
    value: ModuleConfig_RemoteHardwareConfig;
    case: "remoteHardware";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.NeighborInfoConfig neighbor_info = 10;
     */
    value: ModuleConfig_NeighborInfoConfig;
    case: "neighborInfo";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.AmbientLightingConfig ambient_lighting = 11;
     */
    value: ModuleConfig_AmbientLightingConfig;
    case: "ambientLighting";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.DetectionSensorConfig detection_sensor = 12;
     */
    value: ModuleConfig_DetectionSensorConfig;
    case: "detectionSensor";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.PaxcounterConfig paxcounter = 13;
     */
    value: ModuleConfig_PaxcounterConfig;
    case: "paxcounter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message meshtastic.ModuleConfig.
 * Use `create(ModuleConfigSchema)` to create a new message.
 */
export const ModuleConfigSchema: GenMessage<ModuleConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0);

/**
 *
 * MQTT Client Config
 *
 * @generated from message meshtastic.ModuleConfig.MQTTConfig
 */
export type ModuleConfig_MQTTConfig = Message<"meshtastic.ModuleConfig.MQTTConfig"> & {
  /**
   *
   * If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
   * is_uplink_enabled or is_downlink_enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * The server to use for our MQTT global message gateway feature.
   * If not set, the default server will be used
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   *
   * MQTT username to use (most useful for a custom MQTT server).
   * If using a custom server, this will be honoured even if empty.
   * If using the default server, this will only be honoured if set, otherwise the device will use the default username
   *
   * @generated from field: string username = 3;
   */
  username: string;

  /**
   *
   * MQTT password to use (most useful for a custom MQTT server).
   * If using a custom server, this will be honoured even if empty.
   * If using the default server, this will only be honoured if set, otherwise the device will use the default password
   *
   * @generated from field: string password = 4;
   */
  password: string;

  /**
   *
   * Whether to send encrypted or decrypted packets to MQTT.
   * This parameter is only honoured if you also set server
   * (the default official mqtt.meshtastic.org server can handle encrypted packets)
   * Decrypted packets may be useful for external systems that want to consume meshtastic packets
   *
   * @generated from field: bool encryption_enabled = 5;
   */
  encryptionEnabled: boolean;

  /**
   *
   * Whether to send / consume json packets on MQTT
   *
   * @generated from field: bool json_enabled = 6;
   */
  jsonEnabled: boolean;

  /**
   *
   * If true, we attempt to establish a secure connection using TLS
   *
   * @generated from field: bool tls_enabled = 7;
   */
  tlsEnabled: boolean;

  /**
   *
   * The root topic to use for MQTT messages. Default is "msh".
   * This is useful if you want to use a single MQTT server for multiple meshtastic networks and separate them via ACLs
   *
   * @generated from field: string root = 8;
   */
  root: string;

  /**
   *
   * If true, we can use the connected phone / client to proxy messages to MQTT instead of a direct connection
   *
   * @generated from field: bool proxy_to_client_enabled = 9;
   */
  proxyToClientEnabled: boolean;

  /**
   *
   * If true, we will periodically report unencrypted information about our node to a map via MQTT
   *
   * @generated from field: bool map_reporting_enabled = 10;
   */
  mapReportingEnabled: boolean;

  /**
   *
   * Settings for reporting information about our node to a map via MQTT
   *
   * @generated from field: meshtastic.ModuleConfig.MapReportSettings map_report_settings = 11;
   */
  mapReportSettings?: ModuleConfig_MapReportSettings;
};

/**
 * Describes the message meshtastic.ModuleConfig.MQTTConfig.
 * Use `create(ModuleConfig_MQTTConfigSchema)` to create a new message.
 */
export const ModuleConfig_MQTTConfigSchema: GenMessage<ModuleConfig_MQTTConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 0);

/**
 *
 * Settings for reporting unencrypted information about our node to a map via MQTT
 *
 * @generated from message meshtastic.ModuleConfig.MapReportSettings
 */
export type ModuleConfig_MapReportSettings = Message<"meshtastic.ModuleConfig.MapReportSettings"> & {
  /**
   *
   * How often we should report our info to the map (in seconds)
   *
   * @generated from field: uint32 publish_interval_secs = 1;
   */
  publishIntervalSecs: number;

  /**
   *
   * Bits of precision for the location sent (default of 32 is full precision).
   *
   * @generated from field: uint32 position_precision = 2;
   */
  positionPrecision: number;

  /**
   *
   * Whether we have opted-in to report our location to the map
   *
   * @generated from field: bool should_report_location = 3;
   */
  shouldReportLocation: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.MapReportSettings.
 * Use `create(ModuleConfig_MapReportSettingsSchema)` to create a new message.
 */
export const ModuleConfig_MapReportSettingsSchema: GenMessage<ModuleConfig_MapReportSettings> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 1);

/**
 *
 * RemoteHardwareModule Config
 *
 * @generated from message meshtastic.ModuleConfig.RemoteHardwareConfig
 */
export type ModuleConfig_RemoteHardwareConfig = Message<"meshtastic.ModuleConfig.RemoteHardwareConfig"> & {
  /**
   *
   * Whether the Module is enabled
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * Whether the Module allows consumers to read / write to pins not defined in available_pins
   *
   * @generated from field: bool allow_undefined_pin_access = 2;
   */
  allowUndefinedPinAccess: boolean;

  /**
   *
   * Exposes the available pins to the mesh for reading and writing
   *
   * @generated from field: repeated meshtastic.RemoteHardwarePin available_pins = 3;
   */
  availablePins: RemoteHardwarePin[];
};

/**
 * Describes the message meshtastic.ModuleConfig.RemoteHardwareConfig.
 * Use `create(ModuleConfig_RemoteHardwareConfigSchema)` to create a new message.
 */
export const ModuleConfig_RemoteHardwareConfigSchema: GenMessage<ModuleConfig_RemoteHardwareConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 2);

/**
 *
 * NeighborInfoModule Config
 *
 * @generated from message meshtastic.ModuleConfig.NeighborInfoConfig
 */
export type ModuleConfig_NeighborInfoConfig = Message<"meshtastic.ModuleConfig.NeighborInfoConfig"> & {
  /**
   *
   * Whether the Module is enabled
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * Interval in seconds of how often we should try to send our
   * Neighbor Info (minimum is 14400, i.e., 4 hours)
   *
   * @generated from field: uint32 update_interval = 2;
   */
  updateInterval: number;

  /**
   *
   * Whether in addition to sending it to MQTT and the PhoneAPI, our NeighborInfo should be transmitted over LoRa.
   * Note that this is not available on a channel with default key and name.
   *
   * @generated from field: bool transmit_over_lora = 3;
   */
  transmitOverLora: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.NeighborInfoConfig.
 * Use `create(ModuleConfig_NeighborInfoConfigSchema)` to create a new message.
 */
export const ModuleConfig_NeighborInfoConfigSchema: GenMessage<ModuleConfig_NeighborInfoConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 3);

/**
 *
 * Detection Sensor Module Config
 *
 * @generated from message meshtastic.ModuleConfig.DetectionSensorConfig
 */
export type ModuleConfig_DetectionSensorConfig = Message<"meshtastic.ModuleConfig.DetectionSensorConfig"> & {
  /**
   *
   * Whether the Module is enabled
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * Interval in seconds of how often we can send a message to the mesh when a
   * trigger event is detected
   *
   * @generated from field: uint32 minimum_broadcast_secs = 2;
   */
  minimumBroadcastSecs: number;

  /**
   *
   * Interval in seconds of how often we should send a message to the mesh
   * with the current state regardless of trigger events When set to 0, only
   * trigger events will be broadcasted Works as a sort of status heartbeat
   * for peace of mind
   *
   * @generated from field: uint32 state_broadcast_secs = 3;
   */
  stateBroadcastSecs: number;

  /**
   *
   * Send ASCII bell with alert message
   * Useful for triggering ext. notification on bell
   *
   * @generated from field: bool send_bell = 4;
   */
  sendBell: boolean;

  /**
   *
   * Friendly name used to format message sent to mesh
   * Example: A name "Motion" would result in a message "Motion detected"
   * Maximum length of 20 characters
   *
   * @generated from field: string name = 5;
   */
  name: string;

  /**
   *
   * GPIO pin to monitor for state changes
   *
   * @generated from field: uint32 monitor_pin = 6;
   */
  monitorPin: number;

  /**
   *
   * The type of trigger event to be used
   *
   * @generated from field: meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType detection_trigger_type = 7;
   */
  detectionTriggerType: ModuleConfig_DetectionSensorConfig_TriggerType;

  /**
   *
   * Whether or not use INPUT_PULLUP mode for GPIO pin
   * Only applicable if the board uses pull-up resistors on the pin
   *
   * @generated from field: bool use_pullup = 8;
   */
  usePullup: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.DetectionSensorConfig.
 * Use `create(ModuleConfig_DetectionSensorConfigSchema)` to create a new message.
 */
export const ModuleConfig_DetectionSensorConfigSchema: GenMessage<ModuleConfig_DetectionSensorConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 4);

/**
 * @generated from enum meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType
 */
export enum ModuleConfig_DetectionSensorConfig_TriggerType {
  /**
   * Event is triggered if pin is low
   *
   * @generated from enum value: LOGIC_LOW = 0;
   */
  LOGIC_LOW = 0,

  /**
   * Event is triggered if pin is high
   *
   * @generated from enum value: LOGIC_HIGH = 1;
   */
  LOGIC_HIGH = 1,

  /**
   * Event is triggered when pin goes high to low
   *
   * @generated from enum value: FALLING_EDGE = 2;
   */
  FALLING_EDGE = 2,

  /**
   * Event is triggered when pin goes low to high
   *
   * @generated from enum value: RISING_EDGE = 3;
   */
  RISING_EDGE = 3,

  /**
   * Event is triggered on every pin state change, low is considered to be
   * "active"
   *
   * @generated from enum value: EITHER_EDGE_ACTIVE_LOW = 4;
   */
  EITHER_EDGE_ACTIVE_LOW = 4,

  /**
   * Event is triggered on every pin state change, high is considered to be
   * "active"
   *
   * @generated from enum value: EITHER_EDGE_ACTIVE_HIGH = 5;
   */
  EITHER_EDGE_ACTIVE_HIGH = 5,
}

/**
 * Describes the enum meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType.
 */
export const ModuleConfig_DetectionSensorConfig_TriggerTypeSchema: GenEnum<ModuleConfig_DetectionSensorConfig_TriggerType> = /*@__PURE__*/
  enumDesc(file_meshtastic_module_config, 0, 4, 0);

/**
 *
 * Audio Config for codec2 voice
 *
 * @generated from message meshtastic.ModuleConfig.AudioConfig
 */
export type ModuleConfig_AudioConfig = Message<"meshtastic.ModuleConfig.AudioConfig"> & {
  /**
   *
   * Whether Audio is enabled
   *
   * @generated from field: bool codec2_enabled = 1;
   */
  codec2Enabled: boolean;

  /**
   *
   * PTT Pin
   *
   * @generated from field: uint32 ptt_pin = 2;
   */
  pttPin: number;

  /**
   *
   * The audio sample rate to use for codec2
   *
   * @generated from field: meshtastic.ModuleConfig.AudioConfig.Audio_Baud bitrate = 3;
   */
  bitrate: ModuleConfig_AudioConfig_Audio_Baud;

  /**
   *
   * I2S Word Select
   *
   * @generated from field: uint32 i2s_ws = 4;
   */
  i2sWs: number;

  /**
   *
   * I2S Data IN
   *
   * @generated from field: uint32 i2s_sd = 5;
   */
  i2sSd: number;

  /**
   *
   * I2S Data OUT
   *
   * @generated from field: uint32 i2s_din = 6;
   */
  i2sDin: number;

  /**
   *
   * I2S Clock
   *
   * @generated from field: uint32 i2s_sck = 7;
   */
  i2sSck: number;
};

/**
 * Describes the message meshtastic.ModuleConfig.AudioConfig.
 * Use `create(ModuleConfig_AudioConfigSchema)` to create a new message.
 */
export const ModuleConfig_AudioConfigSchema: GenMessage<ModuleConfig_AudioConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 5);

/**
 *
 * Baudrate for codec2 voice
 *
 * @generated from enum meshtastic.ModuleConfig.AudioConfig.Audio_Baud
 */
export enum ModuleConfig_AudioConfig_Audio_Baud {
  /**
   * @generated from enum value: CODEC2_DEFAULT = 0;
   */
  CODEC2_DEFAULT = 0,

  /**
   * @generated from enum value: CODEC2_3200 = 1;
   */
  CODEC2_3200 = 1,

  /**
   * @generated from enum value: CODEC2_2400 = 2;
   */
  CODEC2_2400 = 2,

  /**
   * @generated from enum value: CODEC2_1600 = 3;
   */
  CODEC2_1600 = 3,

  /**
   * @generated from enum value: CODEC2_1400 = 4;
   */
  CODEC2_1400 = 4,

  /**
   * @generated from enum value: CODEC2_1300 = 5;
   */
  CODEC2_1300 = 5,

  /**
   * @generated from enum value: CODEC2_1200 = 6;
   */
  CODEC2_1200 = 6,

  /**
   * @generated from enum value: CODEC2_700 = 7;
   */
  CODEC2_700 = 7,

  /**
   * @generated from enum value: CODEC2_700B = 8;
   */
  CODEC2_700B = 8,
}

/**
 * Describes the enum meshtastic.ModuleConfig.AudioConfig.Audio_Baud.
 */
export const ModuleConfig_AudioConfig_Audio_BaudSchema: GenEnum<ModuleConfig_AudioConfig_Audio_Baud> = /*@__PURE__*/
  enumDesc(file_meshtastic_module_config, 0, 5, 0);

/**
 *
 * Config for the Paxcounter Module
 *
 * @generated from message meshtastic.ModuleConfig.PaxcounterConfig
 */
export type ModuleConfig_PaxcounterConfig = Message<"meshtastic.ModuleConfig.PaxcounterConfig"> & {
  /**
   *
   * Enable the Paxcounter Module
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * @generated from field: uint32 paxcounter_update_interval = 2;
   */
  paxcounterUpdateInterval: number;

  /**
   *
   * WiFi RSSI threshold. Defaults to -80
   *
   * @generated from field: int32 wifi_threshold = 3;
   */
  wifiThreshold: number;

  /**
   *
   * BLE RSSI threshold. Defaults to -80
   *
   * @generated from field: int32 ble_threshold = 4;
   */
  bleThreshold: number;
};

/**
 * Describes the message meshtastic.ModuleConfig.PaxcounterConfig.
 * Use `create(ModuleConfig_PaxcounterConfigSchema)` to create a new message.
 */
export const ModuleConfig_PaxcounterConfigSchema: GenMessage<ModuleConfig_PaxcounterConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 6);

/**
 *
 * Serial Config
 *
 * @generated from message meshtastic.ModuleConfig.SerialConfig
 */
export type ModuleConfig_SerialConfig = Message<"meshtastic.ModuleConfig.SerialConfig"> & {
  /**
   *
   * Preferences for the SerialModule
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: bool echo = 2;
   */
  echo: boolean;

  /**
   *
   * RX pin (should match Arduino gpio pin number)
   *
   * @generated from field: uint32 rxd = 3;
   */
  rxd: number;

  /**
   *
   * TX pin (should match Arduino gpio pin number)
   *
   * @generated from field: uint32 txd = 4;
   */
  txd: number;

  /**
   *
   * Serial baud rate
   *
   * @generated from field: meshtastic.ModuleConfig.SerialConfig.Serial_Baud baud = 5;
   */
  baud: ModuleConfig_SerialConfig_Serial_Baud;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 timeout = 6;
   */
  timeout: number;

  /**
   *
   * Mode for serial module operation
   *
   * @generated from field: meshtastic.ModuleConfig.SerialConfig.Serial_Mode mode = 7;
   */
  mode: ModuleConfig_SerialConfig_Serial_Mode;

  /**
   *
   * Overrides the platform's defacto Serial port instance to use with Serial module config settings
   * This is currently only usable in output modes like NMEA / CalTopo and may behave strangely or not work at all in other modes
   * Existing logging over the Serial Console will still be present
   *
   * @generated from field: bool override_console_serial_port = 8;
   */
  overrideConsoleSerialPort: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.SerialConfig.
 * Use `create(ModuleConfig_SerialConfigSchema)` to create a new message.
 */
export const ModuleConfig_SerialConfigSchema: GenMessage<ModuleConfig_SerialConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 7);

/**
 *
 * TODO: REPLACE
 *
 * @generated from enum meshtastic.ModuleConfig.SerialConfig.Serial_Baud
 */
export enum ModuleConfig_SerialConfig_Serial_Baud {
  /**
   * @generated from enum value: BAUD_DEFAULT = 0;
   */
  BAUD_DEFAULT = 0,

  /**
   * @generated from enum value: BAUD_110 = 1;
   */
  BAUD_110 = 1,

  /**
   * @generated from enum value: BAUD_300 = 2;
   */
  BAUD_300 = 2,

  /**
   * @generated from enum value: BAUD_600 = 3;
   */
  BAUD_600 = 3,

  /**
   * @generated from enum value: BAUD_1200 = 4;
   */
  BAUD_1200 = 4,

  /**
   * @generated from enum value: BAUD_2400 = 5;
   */
  BAUD_2400 = 5,

  /**
   * @generated from enum value: BAUD_4800 = 6;
   */
  BAUD_4800 = 6,

  /**
   * @generated from enum value: BAUD_9600 = 7;
   */
  BAUD_9600 = 7,

  /**
   * @generated from enum value: BAUD_19200 = 8;
   */
  BAUD_19200 = 8,

  /**
   * @generated from enum value: BAUD_38400 = 9;
   */
  BAUD_38400 = 9,

  /**
   * @generated from enum value: BAUD_57600 = 10;
   */
  BAUD_57600 = 10,

  /**
   * @generated from enum value: BAUD_115200 = 11;
   */
  BAUD_115200 = 11,

  /**
   * @generated from enum value: BAUD_230400 = 12;
   */
  BAUD_230400 = 12,

  /**
   * @generated from enum value: BAUD_460800 = 13;
   */
  BAUD_460800 = 13,

  /**
   * @generated from enum value: BAUD_576000 = 14;
   */
  BAUD_576000 = 14,

  /**
   * @generated from enum value: BAUD_921600 = 15;
   */
  BAUD_921600 = 15,
}

/**
 * Describes the enum meshtastic.ModuleConfig.SerialConfig.Serial_Baud.
 */
export const ModuleConfig_SerialConfig_Serial_BaudSchema: GenEnum<ModuleConfig_SerialConfig_Serial_Baud> = /*@__PURE__*/
  enumDesc(file_meshtastic_module_config, 0, 7, 0);

/**
 *
 * TODO: REPLACE
 *
 * @generated from enum meshtastic.ModuleConfig.SerialConfig.Serial_Mode
 */
export enum ModuleConfig_SerialConfig_Serial_Mode {
  /**
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * @generated from enum value: SIMPLE = 1;
   */
  SIMPLE = 1,

  /**
   * @generated from enum value: PROTO = 2;
   */
  PROTO = 2,

  /**
   * @generated from enum value: TEXTMSG = 3;
   */
  TEXTMSG = 3,

  /**
   * @generated from enum value: NMEA = 4;
   */
  NMEA = 4,

  /**
   * NMEA messages specifically tailored for CalTopo
   *
   * @generated from enum value: CALTOPO = 5;
   */
  CALTOPO = 5,

  /**
   * Ecowitt WS85 weather station
   *
   * @generated from enum value: WS85 = 6;
   */
  WS85 = 6,

  /**
   * VE.Direct is a serial protocol used by Victron Energy products
   * https://beta.ivc.no/wiki/index.php/Victron_VE_Direct_DIY_Cable
   *
   * @generated from enum value: VE_DIRECT = 7;
   */
  VE_DIRECT = 7,

  /**
   * Used to configure and view some parameters of MeshSolar.
   * https://heltec.org/project/meshsolar/
   *
   * @generated from enum value: MS_CONFIG = 8;
   */
  MS_CONFIG = 8,
}

/**
 * Describes the enum meshtastic.ModuleConfig.SerialConfig.Serial_Mode.
 */
export const ModuleConfig_SerialConfig_Serial_ModeSchema: GenEnum<ModuleConfig_SerialConfig_Serial_Mode> = /*@__PURE__*/
  enumDesc(file_meshtastic_module_config, 0, 7, 1);

/**
 *
 * External Notifications Config
 *
 * @generated from message meshtastic.ModuleConfig.ExternalNotificationConfig
 */
export type ModuleConfig_ExternalNotificationConfig = Message<"meshtastic.ModuleConfig.ExternalNotificationConfig"> & {
  /**
   *
   * Enable the ExternalNotificationModule
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * When using in On/Off mode, keep the output on for this many
   * milliseconds. Default 1000ms (1 second).
   *
   * @generated from field: uint32 output_ms = 2;
   */
  outputMs: number;

  /**
   *
   * Define the output pin GPIO setting Defaults to
   * EXT_NOTIFY_OUT if set for the board.
   * In standalone devices this pin should drive the LED to match the UI.
   *
   * @generated from field: uint32 output = 3;
   */
  output: number;

  /**
   *
   * Optional: Define a secondary output pin for a vibra motor
   * This is used in standalone devices to match the UI.
   *
   * @generated from field: uint32 output_vibra = 8;
   */
  outputVibra: number;

  /**
   *
   * Optional: Define a tertiary output pin for an active buzzer
   * This is used in standalone devices to to match the UI.
   *
   * @generated from field: uint32 output_buzzer = 9;
   */
  outputBuzzer: number;

  /**
   *
   * IF this is true, the 'output' Pin will be pulled active high, false
   * means active low.
   *
   * @generated from field: bool active = 4;
   */
  active: boolean;

  /**
   *
   * True: Alert when a text message arrives (output)
   *
   * @generated from field: bool alert_message = 5;
   */
  alertMessage: boolean;

  /**
   *
   * True: Alert when a text message arrives (output_vibra)
   *
   * @generated from field: bool alert_message_vibra = 10;
   */
  alertMessageVibra: boolean;

  /**
   *
   * True: Alert when a text message arrives (output_buzzer)
   *
   * @generated from field: bool alert_message_buzzer = 11;
   */
  alertMessageBuzzer: boolean;

  /**
   *
   * True: Alert when the bell character is received (output)
   *
   * @generated from field: bool alert_bell = 6;
   */
  alertBell: boolean;

  /**
   *
   * True: Alert when the bell character is received (output_vibra)
   *
   * @generated from field: bool alert_bell_vibra = 12;
   */
  alertBellVibra: boolean;

  /**
   *
   * True: Alert when the bell character is received (output_buzzer)
   *
   * @generated from field: bool alert_bell_buzzer = 13;
   */
  alertBellBuzzer: boolean;

  /**
   *
   * use a PWM output instead of a simple on/off output. This will ignore
   * the 'output', 'output_ms' and 'active' settings and use the
   * device.buzzer_gpio instead.
   *
   * @generated from field: bool use_pwm = 7;
   */
  usePwm: boolean;

  /**
   *
   * The notification will toggle with 'output_ms' for this time of seconds.
   * Default is 0 which means don't repeat at all. 60 would mean blink
   * and/or beep for 60 seconds
   *
   * @generated from field: uint32 nag_timeout = 14;
   */
  nagTimeout: number;

  /**
   *
   * When true, enables devices with native I2S audio output to use the RTTTL over speaker like a buzzer
   * T-Watch S3 and T-Deck for example have this capability
   *
   * @generated from field: bool use_i2s_as_buzzer = 15;
   */
  useI2sAsBuzzer: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.ExternalNotificationConfig.
 * Use `create(ModuleConfig_ExternalNotificationConfigSchema)` to create a new message.
 */
export const ModuleConfig_ExternalNotificationConfigSchema: GenMessage<ModuleConfig_ExternalNotificationConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 8);

/**
 *
 * Store and Forward Module Config
 *
 * @generated from message meshtastic.ModuleConfig.StoreForwardConfig
 */
export type ModuleConfig_StoreForwardConfig = Message<"meshtastic.ModuleConfig.StoreForwardConfig"> & {
  /**
   *
   * Enable the Store and Forward Module
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: bool heartbeat = 2;
   */
  heartbeat: boolean;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 records = 3;
   */
  records: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 history_return_max = 4;
   */
  historyReturnMax: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 history_return_window = 5;
   */
  historyReturnWindow: number;

  /**
   *
   * Set to true to let this node act as a server that stores received messages and resends them upon request.
   *
   * @generated from field: bool is_server = 6;
   */
  isServer: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.StoreForwardConfig.
 * Use `create(ModuleConfig_StoreForwardConfigSchema)` to create a new message.
 */
export const ModuleConfig_StoreForwardConfigSchema: GenMessage<ModuleConfig_StoreForwardConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 9);

/**
 *
 * Preferences for the RangeTestModule
 *
 * @generated from message meshtastic.ModuleConfig.RangeTestConfig
 */
export type ModuleConfig_RangeTestConfig = Message<"meshtastic.ModuleConfig.RangeTestConfig"> & {
  /**
   *
   * Enable the Range Test Module
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * Send out range test messages from this node
   *
   * @generated from field: uint32 sender = 2;
   */
  sender: number;

  /**
   *
   * Bool value indicating that this node should save a RangeTest.csv file.
   * ESP32 Only
   *
   * @generated from field: bool save = 3;
   */
  save: boolean;

  /**
   *
   * Bool indicating that the node should cleanup / destroy it's RangeTest.csv file.
   * ESP32 Only
   *
   * @generated from field: bool clear_on_reboot = 4;
   */
  clearOnReboot: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.RangeTestConfig.
 * Use `create(ModuleConfig_RangeTestConfigSchema)` to create a new message.
 */
export const ModuleConfig_RangeTestConfigSchema: GenMessage<ModuleConfig_RangeTestConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 10);

/**
 *
 * Configuration for both device and environment metrics
 *
 * @generated from message meshtastic.ModuleConfig.TelemetryConfig
 */
export type ModuleConfig_TelemetryConfig = Message<"meshtastic.ModuleConfig.TelemetryConfig"> & {
  /**
   *
   * Interval in seconds of how often we should try to send our
   * device metrics to the mesh
   *
   * @generated from field: uint32 device_update_interval = 1;
   */
  deviceUpdateInterval: number;

  /**
   * @generated from field: uint32 environment_update_interval = 2;
   */
  environmentUpdateInterval: number;

  /**
   *
   * Preferences for the Telemetry Module (Environment)
   * Enable/Disable the telemetry measurement module measurement collection
   *
   * @generated from field: bool environment_measurement_enabled = 3;
   */
  environmentMeasurementEnabled: boolean;

  /**
   *
   * Enable/Disable the telemetry measurement module on-device display
   *
   * @generated from field: bool environment_screen_enabled = 4;
   */
  environmentScreenEnabled: boolean;

  /**
   *
   * We'll always read the sensor in Celsius, but sometimes we might want to
   * display the results in Fahrenheit as a "user preference".
   *
   * @generated from field: bool environment_display_fahrenheit = 5;
   */
  environmentDisplayFahrenheit: boolean;

  /**
   *
   * Enable/Disable the air quality metrics
   *
   * @generated from field: bool air_quality_enabled = 6;
   */
  airQualityEnabled: boolean;

  /**
   *
   * Interval in seconds of how often we should try to send our
   * air quality metrics to the mesh
   *
   * @generated from field: uint32 air_quality_interval = 7;
   */
  airQualityInterval: number;

  /**
   *
   * Enable/disable Power metrics
   *
   * @generated from field: bool power_measurement_enabled = 8;
   */
  powerMeasurementEnabled: boolean;

  /**
   *
   * Interval in seconds of how often we should try to send our
   * power metrics to the mesh
   *
   * @generated from field: uint32 power_update_interval = 9;
   */
  powerUpdateInterval: number;

  /**
   *
   * Enable/Disable the power measurement module on-device display
   *
   * @generated from field: bool power_screen_enabled = 10;
   */
  powerScreenEnabled: boolean;

  /**
   *
   * Preferences for the (Health) Telemetry Module
   * Enable/Disable the telemetry measurement module measurement collection
   *
   * @generated from field: bool health_measurement_enabled = 11;
   */
  healthMeasurementEnabled: boolean;

  /**
   *
   * Interval in seconds of how often we should try to send our
   * health metrics to the mesh
   *
   * @generated from field: uint32 health_update_interval = 12;
   */
  healthUpdateInterval: number;

  /**
   *
   * Enable/Disable the health telemetry module on-device display
   *
   * @generated from field: bool health_screen_enabled = 13;
   */
  healthScreenEnabled: boolean;

  /**
   *
   * Enable/Disable the device telemetry module to send metrics to the mesh
   * Note: We will still send telemtry to the connected phone / client every minute over the API
   *
   * @generated from field: bool device_telemetry_enabled = 14;
   */
  deviceTelemetryEnabled: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.TelemetryConfig.
 * Use `create(ModuleConfig_TelemetryConfigSchema)` to create a new message.
 */
export const ModuleConfig_TelemetryConfigSchema: GenMessage<ModuleConfig_TelemetryConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 11);

/**
 *
 * Canned Messages Module Config
 *
 * @generated from message meshtastic.ModuleConfig.CannedMessageConfig
 */
export type ModuleConfig_CannedMessageConfig = Message<"meshtastic.ModuleConfig.CannedMessageConfig"> & {
  /**
   *
   * Enable the rotary encoder #1. This is a 'dumb' encoder sending pulses on both A and B pins while rotating.
   *
   * @generated from field: bool rotary1_enabled = 1;
   */
  rotary1Enabled: boolean;

  /**
   *
   * GPIO pin for rotary encoder A port.
   *
   * @generated from field: uint32 inputbroker_pin_a = 2;
   */
  inputbrokerPinA: number;

  /**
   *
   * GPIO pin for rotary encoder B port.
   *
   * @generated from field: uint32 inputbroker_pin_b = 3;
   */
  inputbrokerPinB: number;

  /**
   *
   * GPIO pin for rotary encoder Press port.
   *
   * @generated from field: uint32 inputbroker_pin_press = 4;
   */
  inputbrokerPinPress: number;

  /**
   *
   * Generate input event on CW of this kind.
   *
   * @generated from field: meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_cw = 5;
   */
  inputbrokerEventCw: ModuleConfig_CannedMessageConfig_InputEventChar;

  /**
   *
   * Generate input event on CCW of this kind.
   *
   * @generated from field: meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_ccw = 6;
   */
  inputbrokerEventCcw: ModuleConfig_CannedMessageConfig_InputEventChar;

  /**
   *
   * Generate input event on Press of this kind.
   *
   * @generated from field: meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_press = 7;
   */
  inputbrokerEventPress: ModuleConfig_CannedMessageConfig_InputEventChar;

  /**
   *
   * Enable the Up/Down/Select input device. Can be RAK rotary encoder or 3 buttons. Uses the a/b/press definitions from inputbroker.
   *
   * @generated from field: bool updown1_enabled = 8;
   */
  updown1Enabled: boolean;

  /**
   *
   * Enable/disable CannedMessageModule.
   *
   * @generated from field: bool enabled = 9 [deprecated = true];
   * @deprecated
   */
  enabled: boolean;

  /**
   *
   * Input event origin accepted by the canned message module.
   * Can be e.g. "rotEnc1", "upDownEnc1", "scanAndSelect", "cardkb", "serialkb", or keyword "_any"
   *
   * @generated from field: string allow_input_source = 10 [deprecated = true];
   * @deprecated
   */
  allowInputSource: string;

  /**
   *
   * CannedMessageModule also sends a bell character with the messages.
   * ExternalNotificationModule can benefit from this feature.
   *
   * @generated from field: bool send_bell = 11;
   */
  sendBell: boolean;
};

/**
 * Describes the message meshtastic.ModuleConfig.CannedMessageConfig.
 * Use `create(ModuleConfig_CannedMessageConfigSchema)` to create a new message.
 */
export const ModuleConfig_CannedMessageConfigSchema: GenMessage<ModuleConfig_CannedMessageConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 12);

/**
 *
 * TODO: REPLACE
 *
 * @generated from enum meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar
 */
export enum ModuleConfig_CannedMessageConfig_InputEventChar {
  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: UP = 17;
   */
  UP = 17,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: DOWN = 18;
   */
  DOWN = 18,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: LEFT = 19;
   */
  LEFT = 19,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: RIGHT = 20;
   */
  RIGHT = 20,

  /**
   *
   * '\n'
   *
   * @generated from enum value: SELECT = 10;
   */
  SELECT = 10,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: BACK = 27;
   */
  BACK = 27,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: CANCEL = 24;
   */
  CANCEL = 24,
}

/**
 * Describes the enum meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar.
 */
export const ModuleConfig_CannedMessageConfig_InputEventCharSchema: GenEnum<ModuleConfig_CannedMessageConfig_InputEventChar> = /*@__PURE__*/
  enumDesc(file_meshtastic_module_config, 0, 12, 0);

/**
 *
 * Ambient Lighting Module - Settings for control of onboard LEDs to allow users to adjust the brightness levels and respective color levels.
 * Initially created for the RAK14001 RGB LED module.
 *
 * @generated from message meshtastic.ModuleConfig.AmbientLightingConfig
 */
export type ModuleConfig_AmbientLightingConfig = Message<"meshtastic.ModuleConfig.AmbientLightingConfig"> & {
  /**
   *
   * Sets LED to on or off.
   *
   * @generated from field: bool led_state = 1;
   */
  ledState: boolean;

  /**
   *
   * Sets the current for the LED output. Default is 10.
   *
   * @generated from field: uint32 current = 2;
   */
  current: number;

  /**
   *
   * Sets the red LED level. Values are 0-255.
   *
   * @generated from field: uint32 red = 3;
   */
  red: number;

  /**
   *
   * Sets the green LED level. Values are 0-255.
   *
   * @generated from field: uint32 green = 4;
   */
  green: number;

  /**
   *
   * Sets the blue LED level. Values are 0-255.
   *
   * @generated from field: uint32 blue = 5;
   */
  blue: number;
};

/**
 * Describes the message meshtastic.ModuleConfig.AmbientLightingConfig.
 * Use `create(ModuleConfig_AmbientLightingConfigSchema)` to create a new message.
 */
export const ModuleConfig_AmbientLightingConfigSchema: GenMessage<ModuleConfig_AmbientLightingConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 0, 13);

/**
 *
 * A GPIO pin definition for remote hardware module
 *
 * @generated from message meshtastic.RemoteHardwarePin
 */
export type RemoteHardwarePin = Message<"meshtastic.RemoteHardwarePin"> & {
  /**
   *
   * GPIO Pin number (must match Arduino)
   *
   * @generated from field: uint32 gpio_pin = 1;
   */
  gpioPin: number;

  /**
   *
   * Name for the GPIO pin (i.e. Front gate, mailbox, etc)
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   *
   * Type of GPIO access available to consumers on the mesh
   *
   * @generated from field: meshtastic.RemoteHardwarePinType type = 3;
   */
  type: RemoteHardwarePinType;
};

/**
 * Describes the message meshtastic.RemoteHardwarePin.
 * Use `create(RemoteHardwarePinSchema)` to create a new message.
 */
export const RemoteHardwarePinSchema: GenMessage<RemoteHardwarePin> = /*@__PURE__*/
  messageDesc(file_meshtastic_module_config, 1);

/**
 * @generated from enum meshtastic.RemoteHardwarePinType
 */
export enum RemoteHardwarePinType {
  /**
   *
   * Unset/unused
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   *
   * GPIO pin can be read (if it is high / low)
   *
   * @generated from enum value: DIGITAL_READ = 1;
   */
  DIGITAL_READ = 1,

  /**
   *
   * GPIO pin can be written to (high / low)
   *
   * @generated from enum value: DIGITAL_WRITE = 2;
   */
  DIGITAL_WRITE = 2,
}

/**
 * Describes the enum meshtastic.RemoteHardwarePinType.
 */
export const RemoteHardwarePinTypeSchema: GenEnum<RemoteHardwarePinType> = /*@__PURE__*/
  enumDesc(file_meshtastic_module_config, 0);

